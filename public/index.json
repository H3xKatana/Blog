[{"content":"Introducing Dune OS: Our School\u0026rsquo;s Custom Linux Distribution By kara mohamed mortadha -0xkatana-\nWelcome to Dune OS We’re excited to announce the official release of Dune OS, a custom-built Linux distribution designed specifically for our school. Dune OS is more than just another operating system—it\u0026rsquo;s tailored to meet the needs of our students and teachers, offering a secure, efficient, and highly customizable platform that enhances productivity and learning.\nWhy Dune OS? The idea behind Dune OS started with a simple goal: to provide our school with an operating system that is flexible, fast, and easy to use for new linux users and ready to support the unique needs of our community. We wanted to create something that gives us control over the software we use, ensures privacy and security, and is built on the open-source spirit of collaboration.\nDune OS is designed to make daily tasks easier for both students and teachers, whether you’re coding, running virtual machines, or simply browsing the web.\nKey Features of Dune OS Here are some of the main features that make Dune OS a great fit for our school:\n1. Customized User Interface Dune OS uses the KDE Plasma 5 desktop environment, which is fast, visually appealing, customizable and beginner friendly . We’ve made sure that everything looks great from the moment you boot up, with custom themes, wallpapers, and a personalized splash screen that reflects our school\u0026rsquo;s identity.\n2. Preinstalled Tools Dune OS is equipped with a wide range of tools to support your learning and work, right out of the box. Here are some of the key software packages included:\nVirtualization \u0026amp; Networking: Tools like VirtualBox, QEMU, and Wireshark allow you to create virtual machines, test different operating systems, and analyze network traffic. Educational Software: Programs such as Logisim for digital circuit design and Cisco Packet Tracer for network simulation help you enhance your practical skills in electronics and networking. Software Development Kits: A variety of SDKs like Visual Studio Code, Code::Blocks, Eclipse, and a GitHub Client provide everything you need for programming, project development, and collaboration. Database \u0026amp; Version Control: Tools like SQLite for managing lightweight databases and GitQ for handling version control ensure you’re ready for development and data management tasks. These are just a few examples of the preinstalled software that makes Dune OS fully prepared for educational and professional use from the moment you start it.\n3. Enhanced Security and Privacy Security and privacy are at the core of Dune OS. We\u0026rsquo;ve included background updates that automatically run at boot time, ensuring the system is always secure without interrupting your work. Additionally, applications like Cisco Packet Tracer operate, protecting your data while you study or complete assignments.\n4. Performance Optimized for All Systems Dune OS is optimized for performance, even on older or lower-end hardware. We’ve disabled unnecessary services in KDE Plasma to free up resources, making sure that Dune OS runs smoothly on any computer.\nTechnical Specifications Dune OS is debian based operating system and forked from the mint project with some tweaks like a new desktop envorimont and new updated kernel to 6.18 providing a solid foundation while allowing us to customize everything to fit the needs of our school.\nThe Dune OS ISO is around 5.5GB in size, and need 30 GB storage you can download it from here Dune os iso . Installation is simple and quick, and our welcome screen will guide you through getting started.\nHow Dune OS Was Developed Creating Dune OS has been a collaborative effort involving students, teachers, . We’ve worked hard to customize every aspect of the operating system Our goal was to make Dune OS feel unique and tailor-made for our school.\nThis project is open to contributions from anyone who wants to get involved. Whether you’re interested in coding, design, or testing, we welcome you to help improve Dune OS. You can find the project on GitHub, where you can submit ideas, report bugs, and contribute to the code.\nWhat’s Next for Dune OS? We’re constantly working on new features and updates for Dune OS. Future versions will include even more customization options, improved tools for students, and more optimizations to ensure Dune OS runs as efficiently as possible.\nStay tuned for updates and new releases as we continue to improve Dune OS based on your feedback.\nGetting Started with Dune OS Ready to try Dune OS? Here’s how you can get started:\nDownload the ISO: You can get the latest version of Dune OS from our school server [or insert link]. Install: Follow the instructions on the welcome screen to complete the installation. Learn and Explore: Check out our getting started guides, tutorials, and other resources to help you get the most out of Dune OS. Contributors The development of Dune OS wouldn’t have been possible without the contributions of our talented team. A big thank you to everyone who has dedicated their time and skills to this project:\nkara mohamed : Lead Developer - Responsible for overall development, system customization, and package management. Azouaou Faiçal :: Project Mentor - Provided invaluable guidance and support throughout the development process. Their expertise and advice helped shape the direction of Dune OS and ensured its success. Mohamed Sahrraoui HAMDI : Testing and QA - Performed testing across various hardware setups and ensured stability. We invite anyone interested in contributing to the project to join us. Whether it’s coding, testing, or simply offering feedback, we appreciate your involvement!\nConclusion Dune OS is more than just an operating system—it’s a platform for growth, learning, and collaboration. We’re excited to see how our school community will use it to explore new ideas, build creative projects, and continue our journey in technology. We invite everyone to try Dune OS, share your thoughts, and contribute to its future.\n","permalink":"http://localhost:1313/post/5/duneos/","summary":"Introducing Dune OS: A custom Linux distribution designed for educational purposes with a focus on performance and usability.","title":"Dune OS Official Release"},{"content":"Boolean Arithmetic Boolean arithmetic deals with binary numbers (0s and 1s) and operations such as AND, OR, NOT, and XOR. These operations are fundamental to digital circuits and computer logic.\nAND: The result is 1 if both inputs are 1; otherwise, it is 0. OR: The result is 1 if at least one input is 1; otherwise, it is 0. NOT: The result is the inverse of the input (0 becomes 1, 1 becomes 0). XOR: The result is 1 if only one of the inputs is 1; otherwise, it is 0. Important Notes While both Boolean systems and binary numbers use 0 and 1, Boolean systems focus on logical operations and binary numbers focus on arithmetic and data representation. They are fundamental to digital systems and often work together, such as in the design of ALUs, where Boolean logic controls arithmetic operations on binary numbers.\nBoolean Systems Definition: Boolean systems deal with logical operations and variables that have two possible values: true (1) and false (0). Operations: Common operations include AND, OR, NOT, and XOR, which are fundamental to logic gates and digital circuits. Usage: Boolean logic is primarily used in decision-making processes, control systems, and designing digital circuits like multiplexers, demultiplexers, and arithmetic logic units (ALUs). Base-2 (Binary) Numbers Definition: Binary numbers are a numerical representation system with base 2, using only two digits: 0 and 1. Operations: Binary arithmetic includes addition, subtraction, multiplication, and division, analogous to decimal arithmetic but limited to the digits 0 and 1. Usage: Binary numbers are used to represent data and perform arithmetic in digital systems, including computers and other digital devices. Integers Integers in computer systems are represented in binary form. The two common integer representations are:\nUnsigned Integers: Represent only non-negative numbers. Signed Integers: Use methods like Two\u0026rsquo;s Complement to represent both positive and negative numbers. Addition Binary addition follows the same principles as decimal addition but is limited to 0 and 1:\n0 + 0 = 0 0 + 1 = 1 1 + 0 = 1 1 + 1 = 10 (which is 0 with a carry of 1) For example, adding binary numbers 1101 and 1011:\n1101\r+ 1011\r------\r11000 Negative Numbers In digital systems, negative numbers are commonly represented using the Two\u0026rsquo;s Complement method. This method allows for straightforward binary arithmetic operations, such as addition and subtraction. Let\u0026rsquo;s break down the process and understand why it works.\nOne\u0026rsquo;s Complement To find the One\u0026rsquo;s Complement of a binary number, you simply invert all the bits. This means turning all 1s to 0s and all 0s to 1s.\nTwo\u0026rsquo;s Complement To find the Two\u0026rsquo;s Complement of a binary number, you add 1 to the result of the One\u0026rsquo;s Complement.\nExample: Representing -5 in 8-bit Binary Let\u0026rsquo;s represent -5 using an 8-bit binary number.\nBinary Representation of 5:\nThe binary representation of 5 in 8 bits is 00000101. One\u0026rsquo;s Complement of 5:\nInvert all bits: 00000101 becomes 11111010. Two\u0026rsquo;s Complement of 5:\nAdd 1 to the One\u0026rsquo;s Complement: 11111010 + 1 __________ 11111011 So, the 8-bit binary representation of -5 is 11111011.\nExample for 3 bits 000 = 0 001 = 1 (0...2^(n-1) -1)\r010 = 2\r011 = 3\r100 = -4\r101 = -3 (-1 ... 2^(n-1))\r110 = -2\r111 = -1 Why Two\u0026rsquo;s Complement Works The Two\u0026rsquo;s Complement method works because it transforms the binary number system into a form where subtraction can be performed using addition.\nGeneral Formula for Two\u0026rsquo;s Complement To understand the general formula, consider an n-bit binary number x. The negative of x in Two\u0026rsquo;s Complement can be derived as follows:\n[ \\text{Two\u0026rsquo;s Complement of } x = 2^n - x ]\nHowever, since ( 2^n ) in binary is just a 1 followed by n zeros (e.g., 100000000 for 8 bits, which is 256 in decimal), we subtract x from 2^n.\nSimplified Steps One\u0026rsquo;s Complement:\nThis can be thought of as ( 2^n - 1 - x ), where ( 2^n - 1 ) is just 11111111 for 8 bits. Two\u0026rsquo;s Complement:\nAdd 1 to the One\u0026rsquo;s Complement: ( (2^n - 1 - x) + 1 = 2^n - x ). Using Full Adder for Subtraction With Two\u0026rsquo;s Complement, subtraction becomes addition of a negative number.\nExample: ( y - x ) Instead of subtracting x from y, we add the Two\u0026rsquo;s Complement of x to y:\n[ y - x = y + (-x) ]\nWhere ( -x ) is the Two\u0026rsquo;s Complement of x.\nFull Adder In hardware, this is implemented using a Full Adder chip, which can perform binary addition. The full adder handles carries and performs bit-wise addition, making it suitable for both addition and subtraction (using Two\u0026rsquo;s Complement).\nSummary One\u0026rsquo;s Complement: Invert all bits. Two\u0026rsquo;s Complement: Add 1 to the One\u0026rsquo;s Complement. Two\u0026rsquo;s Complement simplifies binary arithmetic, particularly subtraction. Example: Represent -5 in 8-bit binary as 11111011. Full Adders can be used to perform subtraction by adding the Two\u0026rsquo;s Complement of a number. This method ensures efficient and straightforward binary arithmetic operations, which are crucial in computer systems and digital electronics.\nArithmetic Logic Unit (ALU) The ALU is a critical component of the CPU, responsible for performing arithmetic and logical operations. The ALU can perform:\nArithmetic Operations: Addition, subtraction, multiplication, division. Logical Operations: AND, OR, NOT, XOR. Bitwise Operations: Shift left, shift right. Example of ALU Implementation Let\u0026rsquo;s consider a simple 1-bit ALU that can perform AND, OR, and ADD operations based on control signals.\nExplanation: Zeroing: The zx and zy control signals zero the x and y inputs, respectively. Negating: The nx and ny control signals negate the x and y inputs, respectively. Function: The f control signal selects between AND and ADD operations. Negate Output: The no control signal negates the output. Zero and Negative Flags: The zr flag is set if the output is zero, and the ng flag is set if the output is negative. ","permalink":"http://localhost:1313/post/4/nand2tetris_week2/","summary":"An in-depth exploration of Boolean arithmetic, binary numbers, and their applications in digital systems as part of the Nand2Tetris course.","title":"Nand2Tetris Week 2 Notes: Boolean Arithmetic"},{"content":"From Functions to Truth Tables Identify Variables: Determine all variables involved in the function. List Possible Combinations: For each variable, list all possible combinations. The number of combinations is (2^n), where (n) is the number of variables. Construct Truth Table: Create a truth table that includes all combinations of input variables and their corresponding output values for the given function. From Truth Tables to Functions Identify Terms: Each term in the function corresponds to a row in the truth table where the function\u0026rsquo;s output is 1. Create Sub-Forms: For each row where the function output is 1, create a term composed of the input variables. Use AND gates to combine the variables within each term. If a variable is 0 in a row, use its NOT (complement) in that term. Combine Terms with OR Gates: Use OR gates to combine all the terms created in the previous step. This forms the final function. Implementing Functions with Logic Gates Basic Logic Gates:\nNOT Gate: Inverts the input. AND Gate: Outputs 1 only if all inputs are 1. OR Gate: Outputs 1 if at least one input is 1. NAND Gate:\nA universal gate that can be used to implement any logic function. NOT using NAND: ((x \\text{ NAND } x) = \\text{NOT}(x)) AND using NAND: (x \\text{ AND } y = \\text{NOT}(x \\text{ NAND } y)) OR using NAND: (\\text{NOT}(x) \\text{ NAND } \\text{NOT}(y) = x \\text{ OR } y) Summary:\nAll functions can be implemented using NOT, AND, and OR gates. Any function can also be implemented using only NAND gates due to their versatility. HDL (Hardware Description Language) Purpose: Simplifies the implementation of gates and chips by describing their behavior and structure in a high-level language. It is almost like Java syntax for enums or some classes.\nExample: Implementation of an XOR gate using HDL based on NOT, AND, and OR gates. An automatic testing language will test all the possible results against the expected results to see the behavior of our chip.\nXOR Gate HDL Example CHIP Xor {\rIN a, b; // Input pins\rOUT out; // Output pin\rPARTS:\r// Intermediate signals\rNOT(a=a, out=nota);\rNOT(b=b, out=notb);\rAND(a=a, b=notb, out=and1);\rAND(a=nota, b=b, out=and2);\rOR(a=and1, b=and2, out=out);\r} ","permalink":"http://localhost:1313/post/4/nand2tetris_week1notes/","summary":"A comprehensive guide to understanding the basics of Boolean logic, truth tables, and implementing logic gates in the Nand2Tetris course.","title":"Nand2Tetris Week 1 Notes"},{"content":"Introduction In this Sherlock writeup, we delve into analyzing Windows artifacts, specifically focusing on notification artifacts. All notifications in Windows are stored in a SQLite database within a notification table, typically in XML format.\nTo facilitate analysis, you can use the following Python script to import the database file as a CSV file or utilize any online SQLite viewer.\n# Python script for exporting Windows 10 notification data to CSV # Usage: python WPNtoCSV.py inputDB outputCSV import sqlite3 import csv import sys def generateCSV(csr, outputfilename): csr.execute(\u0026#34;\u0026#34;\u0026#34;SELECT n.\u0026#39;Order\u0026#39;, n.Id, n.Type, nh.PrimaryId AS HandlerPrimaryId, nh.CreatedTime AS HandlerCreatedTime, nh.ModifiedTime AS HandlerModifiedTime, n.Payload, CASE WHEN n.ExpiryTime != 0 THEN datetime((n.ExpiryTime/10000000)-11644473600, \u0026#39;unixepoch\u0026#39;) ELSE n.ExpiryTime END AS ExpiryTime, CASE WHEN n.ArrivalTime != 0 THEN datetime((n.ArrivalTime/10000000)-11644473600, \u0026#39;unixepoch\u0026#39;) ELSE n.ArrivalTime END AS ArrivalTime FROM Notification n INNER JOIN NotificationHandler nh ON n.HandlerID = nh.RecordID\u0026#34;\u0026#34;\u0026#34;) result = csr.fetchall() with open(outputfilename, \u0026#34;w\u0026#34;, newline=\u0026#39;\u0026#39;, encoding=\u0026#34;utf-8\u0026#34;) as f: writer = csv.writer(f, delimiter=\u0026#39;\\t\u0026#39;) writer.writerow(list(map(lambda x: x[0], csr.description))) for line in result: lst = list(line) lst[-2] = \u0026#34;\u0026#34; if lst[-2] == 0 else lst[-2] lst[-1] = \u0026#34;\u0026#34; if lst[-1] == 0 else lst[-1] writer.writerow(lst) def printMetainfo(csr): csr.execute(\u0026#34;SELECT * FROM Metadata\u0026#34;) result = csr.fetchall() print(\u0026#34;\u0026#34;\u0026#34;\\n Notifications - Metadata ------------------------ \u0026#34;\u0026#34;\u0026#34;) for line in result: print(\u0026#34;\\t\u0026#34; + line[0] + \u0026#34;: \u0026#34; + str(line[1])) print() if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) == 3: conn = sqlite3.connect(sys.argv[1]) csr = conn.cursor() printMetainfo(csr) generateCSV(csr, sys.argv[2]) else: print(\u0026#34;\u0026#34;\u0026#34;\\n Windows 10 Notifications to CSV ------------------------------- This script processes the wpndatabase.db notifications database from Windows 10 and gives a truncated, tab-delimited file as output. File location: %APPDATA%\\Local\\Microsoft\\Windows\\\\Notifications\\wpndatabase.db Usage: WPNtoCSV.py inputDB outputCSV Example: WPNtoCSV.py wpndatabase.db notifications.csv \u0026#34;\u0026#34;\u0026#34;) Task Analysis Identify Sender: Analyze the URL to identify the sender of the notification.\nTitle Examination: Examine the titles of the notifications.\nMessage Sender Identification: Determine who is sending the messages.\nRoom Number Analysis: Investigate the significance of room numbers in the notifications.\nPassword Detection: Detect potentially easy-to-find passwords within the messages.\nDrive URL Analysis: Examine plain URLs related to drives.\nTimestamp Conversion: Utilize the provided script to convert timestamps for message delivery.\nimport datetime # Define the timestamp value from the message timestamp_str = \u0026#34;1681986889.660179\u0026#34; # Convert the timestamp string to a float (assuming it\u0026#39;s in seconds since Unix epoch) timestamp_seconds = float(timestamp_str) # Convert the timestamp to a datetime object in UTC timezone utc_datetime = datetime.datetime.utcfromtimestamp(timestamp_seconds) # Print the UTC datetime in a readable format print(\u0026#34;Message Delivered at (UTC):\u0026#34;, utc_datetime) Monetary Value Assessment: Analyze monetary values mentioned, e.g., \u0026ldquo;10000\u0026rdquo;. ","permalink":"http://localhost:1313/post/3/jinglebell/","summary":"Explore Windows artifact analysis focusing on notification artifacts in this Jingle Bell HackTheBox Sherlock writeup.","title":"Jingle Bell HackTheBox Sherlock Writeup"}]